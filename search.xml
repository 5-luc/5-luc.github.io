<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>“开始啦”</title>
    <url>/2020/09/06/page%E2%80%9C%E5%BC%80%E5%A7%8B%E5%95%A6%E2%80%9D/</url>
    <content><![CDATA[<hr>
<h2 id="你好，杨丽"><a href="#你好，杨丽" class="headerlink" title=" 你好，杨丽"></a> 你好，杨丽</h2><p>欢迎来到我的blog！</p>
<h1 id="We-Start"><a href="#We-Start" class="headerlink" title="We Start"></a>We Start</h1><p><img src="https://i01piccdn.sogoucdn.com/10528652845d21ef"></p>
<h3 id="这里是我们爱情记录的开始！"><a href="#这里是我们爱情记录的开始！" class="headerlink" title="这里是我们爱情记录的开始！"></a>这里是我们爱情记录的开始！</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$  这里开启了 &quot;My New life&quot;</span><br></pre></td></tr></table></figure>

<pre><code class="More">
### Run long·long·ago!嘻嘻

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 我们相识💕</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 我们相知💕</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ 我们相爱💕</span><br></pre></td></tr></table></figure>



# l love you！you love me！

+———————————————————————+
##所以
#我们会一直在一起的！！

</code></pre>
]]></content>
      <tags>
        <tag>爱情记录</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么用webpack</title>
    <url>/2021/05/20/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8webpack/</url>
    <content><![CDATA[<p>webpack 的出现和前端模块化的发展密不可分，所以在了解 webpack 之前，需要先了解前端模块化的进化史。</p>
<a id="more"></a>
<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>对于 js 的编写，不能像其他语言一样很好的支持模块化，很多程序会比较臃肿的丢在一个文件里，要把这个程序拆分开使用，两个文件之前变量的传递就是个问题。</p>
<p>模块化的的第一个阶段，是使用的全局模式。假如一个文件要使用另一个文件中的变量，就需要将这个变量定为全局变量，挂到 window  对象上面，这样虽然解决了变量共享的问题，但是这样不仅污染全局对象，而且很容易引起命名冲突覆盖之前的变量。于是，前端模块化的又摸索开始了。</p>
<p>到了第二个阶段，人们开始用对象分装这些数据，这样做避免了命名冲突，但是这些数据可以通过对象直接访问到，即没有做到数据私有化。使得数据不安全。</p>
<p>到了第三个阶段，立即执行函数的引入，很好的解决了数据是私有的问题，但是当前这个模块依赖另一个模块时就不好处理了。</p>
<p>到了第四个阶段，开始出现引入依赖的思想，诸如 commonjs、AMD、ES6 等等规范，他们都是将一个文件作为一个模块来看待，但是浏览器并不识别他们，所以中间就需要一个东西来翻译一下，让浏览器看的懂，即将他们转成浏览器能读懂的 js ，这个时候 webpack 就出现了，它就充当了这个翻译的角色。</p>
<p>下面看一个 demo 感受一下。这个 demo 要实现的主体效果是我一个文件里定义了变量，在另一个文件里引用它输出。</p>
<h2 id="二、传统开发"><a href="#二、传统开发" class="headerlink" title="二、传统开发"></a>二、传统开发</h2><p>先看没有使用 webpack 的场景。首先在你的工程下创建一个 index.html 文件，在 js 目录下再分别创建 a.js 和 b.js 文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/a.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./js/b.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>1）定义变量</p>
<p>a.js 文件中定义一个变量，要想让令一个文件中能访问到，就要把它挂到全局。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.msg = <span class="string">'yin'</span>;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>2）引用变量</p>
<p>b.js 文件中输出这个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'msg: '</span>, msg);</span><br></pre></td></tr></table></figure>
<p>3）查看结果</p>
<p>打开浏览器控制台可以看到如下效果：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyk86igfdj31bu05cwev.jpg" alt=""></p>
<h2 id="三、模块化开发"><a href="#三、模块化开发" class="headerlink" title="三、模块化开发"></a>三、模块化开发</h2><p>1）导出变量</p>
<p>使用 exports 导出变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'yin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;<span class="attr">msg</span>: msg&#125;;</span><br></pre></td></tr></table></figure>
<p>2）引入变量</p>
<p>在另一个文件中，以 require 的方式导入数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="built_in">require</span>(<span class="string">'./a.js'</span>).msg;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'msg: '</span>, msg);</span><br></pre></td></tr></table></figure>
<p>3）运行</p>
<p>在控制台运行 b.js 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node b.js</span><br></pre></td></tr></table></figure>
<p>可以看到控制台输出内容，但是到了浏览器中刷新的时候，会发现报错</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcykdh2e5oj31by068q42.jpg" alt=""></p>
<p>这是意料之中的事情，因为浏览器本身不认识 node，要让它认识就需要拿 webpack 来编译一下。所以用 npm 先全局装一下 webpack</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install webpack -g</span><br><span class="line"></span><br><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></table></figure>
<p>这里将编译后的内容放到 dist 目录下，命名为 bundle.js，所以 html 文件中重新改一下引用方式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./dist/bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后编译一下，刷新浏览器，内容就又正常显示了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">webpack ./js/b.js -o ./dist/bundle.js</span><br></pre></td></tr></table></figure>
<h2 id="四、优化"><a href="#四、优化" class="headerlink" title="四、优化"></a>四、优化</h2><p>1）配置 package.json 文件</p>
<p>对于编程来说，每次编译跑这么长代码很不优雅，webpack 给我们提供了很多配置，其中可以对指令进行配置，首先运行 <strong>npm init</strong>  安装 package.json 文件，然后局部安装 webpack，并在 scripts 中配置 <strong>“build”: “node_modules/.bin/webpack”</strong> 这一行，如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"node_modules/.bin/webpack"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）配置 webpack.config.js 文件</p>
<p>这里写程序编译的出口和入口。    </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./js/b.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）运行</p>
<p>每次编译只需要运行<strong>npm run build</strong> 即可，刷新浏览器，控制台内容也正常输出。最终项目结构如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/00831rSTly1gcyn60zyucj314a0iy0w9.jpg" alt=""></p>
<div class="qr-code"></div><div class="post-tag-list">标签: <a class="post-tags" href="/tags/网络安全/">网络安全</a>]]></content>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/2021/05/20/websocket/</url>
    <content><![CDATA[<p><a id="more"></a></p>
<p>之后 comet 的出现实现了内容上的实时更新，但是 HTTP 本身的问题并未解决（通信只能客户端发起），于是出现了 WebSocket 协议。</p>
<blockquote>
<p>comet 是一种服务器向页面推送数据的技术，实现方式有长轮询和 HTTP 流。</p>
</blockquote>
<h2 id="二、WebSocket-协议"><a href="#二、WebSocket-协议" class="headerlink" title="二、WebSocket 协议"></a>二、WebSocket 协议</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>WebSocket 协议是 WEB 浏览器和 WEB 服务器全双工通信的标准。诞生于 2008 年，2011 年成为国际标准，目前支持的浏览器有 Firefox 6+、Safari 5+、Chrome、iOS 4+版Safari。</p>
<p>WebSocket 协议建立在 HTTP 协议基础之上，所以连接的发起方仍是客户端，一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。协议的标识符是ws，加密的是wss。</p>
<h3 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h3><ul>
<li>服务器向客户直接端推送数据。</li>
<li>首部信息量小，通信量减少。</li>
<li>没有同源的限制。</li>
</ul>
<h3 id="3、通信过程"><a href="#3、通信过程" class="headerlink" title="3、通信过程"></a>3、通信过程</h3><p>WebSocket 通信需要在 HTTP 连接建立之后完成一次握手步骤。</p>
<p>客户端向服务器发送一个请求。需要用到 HTTP 的 Upgrade、Connection 首部字段，告知服务器通信协议发生改变。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /chat HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class="line">Origin: http://example.com</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sec-WebSocket-Key 字段内记录着握手过程中必不可少的键值。</span></span><br><span class="line"><span class="comment"># Sec-WebSocket-Protocol 字段内记录使用的子协议。子协议按 WebSocket 协议标准在连接分开使用时，定义那些连接的名称。</span></span><br></pre></td></tr></table></figure>
<p>服务器收到请求后向客户端返回一个状态码 101 的响应。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sec-WebSocket-Accept 的字段值是由握手请求中的 Sec-WebSocket-Key 的字段值生成的。</span></span><br></pre></td></tr></table></figure>
<p>成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfylnc3b91j30wg0le11f.jpg" alt=""></p>
<h3 id="4、WebSocket-API"><a href="#4、WebSocket-API" class="headerlink" title="4、WebSocket API"></a>4、WebSocket API</h3><blockquote>
<p>更多详情 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket</a></p>
</blockquote>
<h4 id="1）构造函数"><a href="#1）构造函数" class="headerlink" title="1）构造函数"></a>1）构造函数</h4><p>WebSocket(url[, protocols])，返回一个 <code>WebSocket</code> 对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> WebSocket(url); <span class="comment">// url 是绝对 url</span></span><br></pre></td></tr></table></figure>
<p>实例化 WebSocket 对象后，浏览器就会马上尝试创建连接。</p>
<h4 id="2）属性"><a href="#2）属性" class="headerlink" title="2）属性"></a>2）属性</h4><ul>
<li>readyState</li>
</ul>
<p>与 XHR 类似，WebSocket 也有一个表示当前状态的 readyState 属性，但是的值与 XHR 并不相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONNECTING：值为0，表示正在连接。</span><br><span class="line">OPEN：值为1，表示连接成功，可以通信了。</span><br><span class="line">CLOSING：值为2，表示连接正在关闭。</span><br><span class="line">CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</span><br></pre></td></tr></table></figure>
<h4 id="3）方法"><a href="#3）方法" class="headerlink" title="3）方法"></a>3）方法</h4><ul>
<li>send：对要传输的数据进行排队。（复杂的数据，在发送之前要进行序列化）</li>
<li>close：关闭当前链接。</li>
</ul>
<h4 id="4）事件"><a href="#4）事件" class="headerlink" title="4）事件"></a>4）事件</h4><p>使用 <code>addEventListener()</code> 或将一个事件监听器赋值给本接口的 <code>oneventname</code> 属性监听下面的事件。</p>
<ul>
<li>open：当一个 WebSocket 连接成功时触发。</li>
<li>close：当一个 WebSocket 连接被关闭时触发。</li>
<li>message：当通过 WebSocket 收到数据时触发。</li>
<li>error：当一个 WebSocket 连接因错误而关闭时触发，例如无法发送数据时。</li>
</ul>
<h2 id="三、实战"><a href="#三、实战" class="headerlink" title="三、实战"></a>三、实战</h2><h3 id="1、客户端"><a href="#1、客户端" class="headerlink" title="1、客户端"></a>1、客户端</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">"ws://localhost:8888"</span>);</span></span><br><span class="line"><span class="undefined">  </span></span><br><span class="line"><span class="javascript">  ws.onopen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'server open'</span>);</span></span><br><span class="line"><span class="javascript">    ws.send(<span class="string">'hello world, server!'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  ws.onmessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"client receive data："</span>, e.data);</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  ws.onclose = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"server close"</span>);</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2、服务器"><a href="#2、服务器" class="headerlink" title="2、服务器"></a>2、服务器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> WebSocket = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket.Server(&#123; <span class="attr">port</span>: <span class="number">8888</span> &#125;);</span><br><span class="line"></span><br><span class="line">ws.on(<span class="string">'connection'</span>, ws =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'websocket connection'</span>);</span><br><span class="line">  </span><br><span class="line">  ws.send(<span class="string">'hello world, client!'</span>);</span><br><span class="line">  </span><br><span class="line">  ws.on(<span class="string">'open'</span>, msg =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server open'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ws.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server receive msg：'</span>, msg);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  ws.on(<span class="string">'close'</span>, msg =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'client close'</span>,);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Koa is listening in <span class="subst">$&#123;<span class="number">3000</span>&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<div class="qr-code"></div><div class="post-tag-list">标签: <a class="post-tags" href="/tags/网络安全/">网络安全</a>
]]></content>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端数据存储方案</title>
    <url>/2021/05/20/%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p><a id="more"></a></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gh06exiu2nj31nw0u0n2h.jpg" alt=""></p>
<p><br></p>
<h2 id="一、Cookie"><a href="#一、Cookie" class="headerlink" title="一、Cookie"></a>一、Cookie</h2><h3 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h3><p>Cookie 指某些网站为了辨别用户身份而储存在用户本地终端上的数据。每次请求都会把本地的 Cookie 发到服务器，让服务器知道当前用户的状态。</p>
<p>Cookie 有域的概念，不能跨域操作。</p>
<h3 id="2、适用场景"><a href="#2、适用场景" class="headerlink" title="2、适用场景"></a>2、适用场景</h3><p>适合客户端存储较少的数据，用于标识状态（用户登录状态、购物车等）。</p>
<h3 id="3、特点"><a href="#3、特点" class="headerlink" title="3、特点"></a>3、特点</h3><p><strong>1）数据存放位置</strong>：客户端浏览器缓存中。</p>
<p><strong>2）数据存储大小</strong>：Cookie 存储的数据不能超过 4 KB，浏览器支持的 Cookie 是30～50个，IE6 20个。</p>
<p><strong>3）数据有效期</strong>：cookie 支持设置数据过期时间。</p>
<p><strong>4）数据作用域</strong>：cookie 在所有同源窗口中共享。</p>
<h3 id="4、缺点"><a href="#4、缺点" class="headerlink" title="4、缺点"></a>4、缺点</h3><p>Cookie 容量小（4K）；不安全，容易被拦截暴露数据。</p>
<h3 id="5、API"><a href="#5、API" class="headerlink" title="5、API"></a>5、API</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Document/cookie</a></p>
<h3 id="6、HTTP-请求头字段相关"><a href="#6、HTTP-请求头字段相关" class="headerlink" title="6、HTTP 请求头字段相关"></a>6、HTTP 请求头字段相关</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1）Expires：cookie最长有效期</span><br><span class="line">2）Max-Age：在 cookie 失效之前需要经过的秒数。（当Expires和Max-Age同时存在时，以 Max-Age 为准）</span><br><span class="line">3）Domain：指定 cookie 可以送达的主机名。</span><br><span class="line">4）Path：指定一个 URL 路径，这个路径必须出现在要请求的资源的路径中才可以发送 Cookie 首部</span><br><span class="line">5）Secure：一个带有安全属性的 cookie 只有在请求使用SSL和HTTPS协议的时候才会被发送到服务器。</span><br><span class="line">6）HttpOnly: 设置了 HttpOnly 属性的 cookie 不能使用 JavaScript 经由 Document.cookie 属性、XMLHttpRequest 和 Request APIs 进行访问，以防范跨站脚本攻击（XSS）。</span><br></pre></td></tr></table></figure>
<p><br></p>
<h3 id="二、Web-Storage"><a href="#二、Web-Storage" class="headerlink" title="二、Web Storage"></a>二、Web Storage</h3><h3 id="1、概念-1"><a href="#1、概念-1" class="headerlink" title="1、概念"></a>1、概念</h3><p>Web Storage 有 sessionStorage 和 localStorage 两种存储机制。</p>
<p>sessionStorage 为每一个给定的源维持一个独立的存储区域，该存储区域在页面会话期间可用；localStorage 在浏览器关闭，然后重新打开后数据仍然存在，可用作持久存储数据。</p>
<h3 id="2、适用场景-1"><a href="#2、适用场景-1" class="headerlink" title="2、适用场景"></a>2、适用场景</h3><p>适合客户端存储较少的数据，且数字存储时会转成字符串。</p>
<h3 id="3、特点-1"><a href="#3、特点-1" class="headerlink" title="3、特点"></a>3、特点</h3><p><strong>1）数据存放位置</strong>：sessionStorage 和 localStorage 的数据仅在本地保存，不会自动发送给服务器。</p>
<p><strong>2）数据存储大小</strong>：5M。</p>
<p><strong>3）数据有效期</strong>：sessionStorage 仅在当前浏览器窗口关闭之前有效；localStorage 始终有效，窗口或浏览器关闭也一直保存。</p>
<p><strong>4）数据作用域</strong>：sessionStorage 即使同一页面，不同的浏览器窗口中也不共享；localstorage 在所有同源窗口中都共享。</p>
<p><strong>5）同步：</strong>操作数据是同步的。</p>
<h3 id="4、缺点-1"><a href="#4、缺点-1" class="headerlink" title="4、缺点"></a>4、缺点</h3><p>不能用于存储重要信息，本地储存数据都容易被篡改，容易受到 XSS 攻击。</p>
<h3 id="5、API-1"><a href="#5、API-1" class="headerlink" title="5、API"></a>5、API</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Storage_API/</a></p>
<p><br></p>
<h2 id="三、IndexedDB"><a href="#三、IndexedDB" class="headerlink" title="三、IndexedDB"></a>三、IndexedDB</h2><h3 id="1、概念-2"><a href="#1、概念-2" class="headerlink" title="1、概念"></a>1、概念</h3><p>IndexedDB 是一种在用户浏览器中持久存储数据的方法，用于客户端存储大量结构化数据(包括文件/ 二进制大型对象(blobs)。</p>
<h3 id="2、适用场景-2"><a href="#2、适用场景-2" class="headerlink" title="2、适用场景"></a>2、适用场景</h3><p>适合客户端存储大量结构化数据。</p>
<h3 id="3、特点-2"><a href="#3、特点-2" class="headerlink" title="3、特点"></a>3、特点</h3><p><strong>1）键值对储存：</strong> IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括字符串、JavaScript 对象、二进制数据（ArrayBuffer 对象和 Blob 对象）。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<p><strong>2）数据存储大小</strong>： 取决于硬盘大小，<strong>全局限制</strong>为可用磁盘空间的50％。如果超过此范围，则会发起称为<strong>源回收</strong>的过程，删除整个源的数据，直到存储量再次低于限制。删除源数据没有只删一部分的说法——因为这样可能会导致不一致的问题。<strong>组限制</strong>——这被定义为全局限制的20％，但它至少有10 MB，最大为2GB。</p>
<p><strong>3）异步：</strong> IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<p><strong>4）支持事务：</strong> IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<p><strong>5）同源限制：</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<h3 id="4、缺点-2"><a href="#4、缺点-2" class="headerlink" title="4、缺点"></a>4、缺点</h3><p>不能设置数据存储的范围，数据太多时就比较占内存。</p>
<h3 id="5、API-2"><a href="#5、API-2" class="headerlink" title="5、API"></a>5、API</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API/</a></p>
<h3 id="6、第三方类库"><a href="#6、第三方类库" class="headerlink" title="6、第三方类库"></a>6、第三方类库</h3><ul>
<li><a href="https://localforage.github.io/localForage/" target="_blank" rel="noopener">localForage</a>：一个简单名称的Polyfill：客户端数据存储的值语法，它在后台使用IndexedDB，但在不支持IndexedDB的浏览器中回退到WebSQL或localStorage。</li>
<li><a href="http://www.dexie.org/" target="_blank" rel="noopener">Dexie.js</a>：IndexedDB的包装器，通过简单的语法，可以更快地进行代码开发。</li>
<li><a href="https://pouchdb.com/" target="_blank" rel="noopener">PouchDB</a>：使用IndexedDB在浏览器中实现CouchDB的客户端。</li>
<li><a href="https://github.com/jakearchibald/idb" target="_blank" rel="noopener">idb</a>：一个微小的（〜1.15k）库，主要反映了IndexedDB的API，但小的改进，使一个很大的区别的可用性。</li>
</ul>
<p><br></p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><p><a href="http://www.ruanyifeng.com/blog/2018/07/indexeddb.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/indexeddb.html</a></p>
<p><br></p>


</div><div class="post-tag-list">标签: <a class="post-tags" href="/tags/Web-前端/">Web 前端</a>]]></content>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>概述</title>
    <url>/2021/05/20/%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>2）凡是将分布在不同地理位置上的具有独立工作能力的计算机、终端及其附属设备，用通信设备和通信线路连接起来，并配置网络软件和通信协议，以实现数据传输和资源共享的系统就叫做计算机网络。</p>
<p>3）Internet：译名有因特网和互联网，但是流行的是互联网。它是由数量极大的各种计算机网络互联起来的。互联网是世界上最大的计算机网络。</p>
<h3 id="2、计算机网络的功能"><a href="#2、计算机网络的功能" class="headerlink" title="2、计算机网络的功能"></a>2、计算机网络的功能</h3><p>连通性和资源共享</p>
<h2 id="二、互联网的标准化工作"><a href="#二、互联网的标准化工作" class="headerlink" title="二、互联网的标准化工作"></a>二、互联网的标准化工作</h2><h3 id="1、标准组织"><a href="#1、标准组织" class="headerlink" title="1、标准组织"></a>1、标准组织</h3><p>因特网协会【ISOC】：管理互联网 </p>
<p>=&gt; 互联网系结构委员会【IAB】 </p>
<p>=&gt; 互联网工程部【IETF】（针对协议的开发和标准化）、互联网研究部【IRTF】（针对互联网上的协议、应用、体系结构）</p>
<h3 id="2、标准制定"><a href="#2、标准制定" class="headerlink" title="2、标准制定"></a>2、标准制定</h3><p>互联网草案，建议标准（RFC），互联网标准（RFC） 。</p>
<h2 id="三、互联网的组成"><a href="#三、互联网的组成" class="headerlink" title="三、互联网的组成"></a>三、互联网的组成</h2><h3 id="1、边缘部分"><a href="#1、边缘部分" class="headerlink" title="1、边缘部分"></a>1、边缘部分</h3><p>1）概念</p>
<p>由所有连接在互联网上的主机组成，用来进行通信和资源共享。</p>
<p>2）端系统之间的通信方式</p>
<ul>
<li>客户—服务器方式（cs）</li>
<li>对等方式（p2p）：每个主机即是客户又是服务器。</li>
</ul>
<h3 id="2、核心部分"><a href="#2、核心部分" class="headerlink" title="2、核心部分"></a>2、核心部分</h3><p>1）概念</p>
<p>由大量网络设施和连接这些网络的路由器组成，用来提供服务。</p>
<p>2）电路交换</p>
<p>必须经历建立连接——通话——释放连接的交换方式。</p>
<p>过程：整个报文的比特流连续地从源点直达。</p>
<p>3）报文交换（已不使用）</p>
<p>过程：整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</p>
<p>3）分组交换</p>
<p>采用存储转发技术，把一个报文划分成几个分组进行传送。（不需要建立连接和释放连接）</p>
<p>过程：路由器收到一个分组，先暂时存储一下，检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去，把分组交给下一个路由器。这样一步一步地以存储转发的方式，把分组交付最终的目的主机。</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/d198c78d-bf51-4d7c-b21f-7ec067a66052.png" alt=""></p>
<h2 id="四、计算机网络的分类"><a href="#四、计算机网络的分类" class="headerlink" title="四、计算机网络的分类"></a>四、计算机网络的分类</h2><h3 id="1、按作用范围分类"><a href="#1、按作用范围分类" class="headerlink" title="1、按作用范围分类"></a>1、按作用范围分类</h3><p>1）广域网（WAN）：覆盖全球</p>
<p>2）城域网（LAN）：山西移动</p>
<p>3）局域网（LAN）：校园网</p>
<p>4）个人区域网（LAN）：家里的网</p>
<h3 id="2、按使用者分类"><a href="#2、按使用者分类" class="headerlink" title="2、按使用者分类"></a>2、按使用者分类</h3><p>1）公用网：所有人都能用的网</p>
<p>2）专用网：只能自己用，别人不能用</p>
<h3 id="3、接入网"><a href="#3、接入网" class="headerlink" title="3、接入网"></a>3、接入网</h3><p>是某用户端系统到互联网的第一个路由器之间的一种网络。</p>
<h2 id="五、计算机网络的性能"><a href="#五、计算机网络的性能" class="headerlink" title="五、计算机网络的性能"></a>五、计算机网络的性能</h2><h3 id="1、性能指标"><a href="#1、性能指标" class="headerlink" title="1、性能指标"></a>1、性能指标</h3><p>1）速率</p>
<p>主机在数据信道上传送数据的速率。</p>
<p>2）带宽</p>
<p>单位时间内从网络的某一点到另一点所能通过的最高数据率。</p>
<p>3）吞吐量</p>
<p>单位时间内通过某个网络的数据量。</p>
<p>4）时延</p>
<p>数据从网络的一个端传到另一个端所需要的时间。</p>
<p>时延=发送时延+传播时延+处理时延+排队时延</p>
<p>5）时延带宽积</p>
<p>时延带宽积=传播时延X带宽</p>
<p>6）往返时间</p>
<p>7）利用率</p>
<ul>
<li>信道利用率</li>
<li>网络利用率</li>
</ul>
<h3 id="2、非性能指标"><a href="#2、非性能指标" class="headerlink" title="2、非性能指标"></a>2、非性能指标</h3><p> 费用、质量、可靠性等。</p>
<h2 id="六、计算机网络的体系结构"><a href="#六、计算机网络的体系结构" class="headerlink" title="六、计算机网络的体系结构"></a>六、计算机网络的体系结构</h2><h3 id="1、协议"><a href="#1、协议" class="headerlink" title="1、协议"></a>1、协议</h3><p>1）概念：为进行网络中的数据交换而建立的规则、标准或约定。</p>
<p>2）协议三要素</p>
<ul>
<li>语法：数据与控制信息的结构或格式</li>
<li>语义：需要发出什么控制信息，完成什么动作作出什么响应</li>
<li>同步：事件实现顺序的详细说明</li>
</ul>
<h3 id="2、分类"><a href="#2、分类" class="headerlink" title="2、分类"></a>2、分类</h3><p>1）OSI 七层协议体系结构：理论完整，但是复杂不实用</p>
<p>2）TCP/IP 四层协议体系结构：得到了广泛应用</p>
<p>3）五层协议体系结构：学习的时候综合二者有点来学，边缘部分占有五层，核心部分只在第三层</p>
<table>
<thead>
<tr>
<th></th>
<th>任务</th>
<th>协议</th>
<th>数据单元</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>用不同的协议分装不同的数据。</td>
<td>FTP，TFTP，HTTP，SMTP，DNS，TELNET</td>
<td>报文</td>
</tr>
<tr>
<td>传输层</td>
<td>向两台主机之间的进程进行通信提供通用的数据传输服务</td>
<td>TCP，UDP</td>
<td>报文</td>
</tr>
<tr>
<td>网络层</td>
<td>将报文分成等长的分组 。</td>
<td>IP，ICMP，IGMP，RIP</td>
<td>分组、包、数据报</td>
</tr>
<tr>
<td>数据链路层</td>
<td>高低电平和01信号的转换。</td>
<td>PPP，ARP，RARP</td>
<td>数据帧</td>
</tr>
<tr>
<td>物理层</td>
<td>传输数据</td>
<td>—</td>
<td>比特</td>
</tr>
</tbody>
</table>
</div><div class="post-tag-list">标签: <a class="post-tags" href="/tags/网络安全/">网络安全]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL用户、权限及密码操作</title>
    <url>/2021/05/20/MySQL%E7%94%A8%E6%88%B7%E3%80%81%E6%9D%83%E9%99%90%E5%8F%8A%E5%AF%86%E7%A0%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h5 id="MySQL中对于用户的权限比较简单，本文主要是分为创建用户、修改用户权限、修改用户密码、删除用户等几部分，介绍MySQL对于用户权限的管理。"><a href="#MySQL中对于用户的权限比较简单，本文主要是分为创建用户、修改用户权限、修改用户密码、删除用户等几部分，介绍MySQL对于用户权限的管理。" class="headerlink" title="### MySQL中对于用户的权限比较简单，本文主要是分为创建用户、修改用户权限、修改用户密码、删除用户等几部分，介绍MySQL对于用户权限的管理。"></a>### MySQL中对于用户的权限比较简单，本文主要是分为创建用户、修改用户权限、修改用户密码、删除用户等几部分，介绍MySQL对于用户权限的管理。</h5><h2 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1 创建用户"></a>1 创建用户</h2><p>###1.1 create user<br>格式如下:</p>
<p><code>CREATE USER &#39;username&#39;@&#39;hostname&#39; IDENTIFIED BY &#39;password&#39;;</code></p>
<p>其中，username为用户名；hostname为主机，localhost指本地用户，通配符%指可以从远程主机登陆用户，如果不指定host，则默认为%；password为密码，可以为空。</p>
<p>例如，创建用户名为user、密码为123456的用户，主机为本地，则</p>
<p><code>CREATE USER &#39;user&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;123456&#39;;</code></p>
<p>创建用户名为user、密码为123456的用户，主机为192.168.1.1，则</p>
<p><code>CREATE USER &#39;user&#39;@&#39;192.168.1.1&#39; IDENTIFIED BY &#39;123456&#39;;</code></p>
<p>创建用户名为user、密码为123456的用户，则</p>
<p><code>CREATE USER &#39;user&#39; IDENTIFIED BY &#39;123456&#39;;</code></p>
<p>创建用户名为user，则</p>
<p><code>CREATE USER user;</code></p>
<p>####注：这种方式需要登录mysql控制台，且登录用户需要CREATE USER权限。</p>
<h3 id="1-2-insert-into-mysql-user"><a href="#1-2-insert-into-mysql-user" class="headerlink" title="1.2 insert into mysql.user"></a>1.2 insert into mysql.user</h3><p>格式如下：</p>
<p><code>INSERT INTO mysql.user(host, user, password) VALUES(hostname, username, PASSWORD(password)); FLUSH PRIVILEGES;</code></p>
<p>其中，mysql.user是在mysql库中存储用户信息的user表，hostname表示主机名（localhost指本地用户，通配符%指可以从远程主机登陆用户），第二个password是密码（第一个password是字段）。</p>
<p>例如，创建用户名为user、密码为123456的用户，则</p>
<p><code>INSERT INTO mysql.user(host, user, password) VALUES(&#39;localhost&#39;, &#39;user&#39;, PASSWORD(&#39;123456&#39;)); FLUSH PRIVILEGES;</code><br>####注：因为这种方式是手动修改数据库，如果想要这种修改立马生效，还需执行FLUSH PRIVILEGES命令刷新用户权限列表，所以需要登录的用户有SELECT、UPDATE、RELOAD三种权限。</p>
<p>##2 修改用户权限<br>###2.1 为用户赋予权限<br>在MySQL中使用GRANT命令给用户授权，如果用户不存在，GRANT会自动创建用户，并进行授权。</p>
<p>格式如下：</p>
<p><code>GRANT privileges ON databases.tablename TO &#39;username&#39;@&#39;hostname&#39; [INDENTIFIED BY ‘password’];</code></p>
<p>其中，privileges表示具体的权限名称，多个权限间通过逗号隔开；databases表示数据库，使用<em>表示所有数据库；tablename表示表名，使用</em>表示所有表；username表示用户名；hostname表示主机名；password表示密码，[]中用于创建用户时为用户添加密码。</p>
<p>###2.2 常用权限</p>
<p>·表数据: select, update, delete, insert</p>
<p>·表结构: create, alert, drop</p>
<p>·外键: references</p>
<p>·创建临时表: create temporary tables</p>
<p>·操作索引: index</p>
<p>·视图: create view, show view</p>
<p>·存储过程: create routine, alert routine, execute</p>
<p>·所有权限: all<br>###2.3 权限表<br>·存储过程权限表: mysql.procs_priv</p>
<p>·列权限表: mysql.columns_priv</p>
<p>·表格权限表: mysql.tables_priv</p>
<p>·用户权限表: information_schema.user_privileges（字段grantee为授权者， 字段privilege_type为权限名称）</p>
<p>·用户信息及权限： mysql.user（后缀为_priv的字段的值与user_privileges的privilege_type一一对应）</p>
<p>###2.4 查看用户权限</p>
<p>查看用户权限可以通过查询上面的权限表的数据进行查询，或者通过show grants命令进行查询，格式如下：</p>
<p><code>SHOW GRANTS [FOR username@hostname]</code></p>
<p>其中，username表示用户名，hostname表示主机名，[]中的内容可以省略，是查询当前登录用户的权限。</p>
<p>###2.5 撤销权限</p>
<p>可以通过命令撤销某用户的某种权限，格式如下：</p>
<p><code>REVOKE privileges ON databease.table FROM username@hostname</code></p>
<p>撤销权限与赋予权限命令相似，区别在于将TO改为FROM。</p>
<p>##3 修改用户密码</p>
<p>###3.1 mysqladmin命令</p>
<p>格式如下：</p>
<p><code>mysqladmin -u USER -p password NEW_PASSWORD</code></p>
<p>其中，USER为用户名，NEW_PASSWORD为新密码。</p>
<p>该命令直接在命令行中执行，回车之后会提示输入原密码，输入正确后即可修改。</p>
<p>例如，设置用户user的密码为123456，原密码为654321，则</p>
<p><code>mysqladmin -u user -p password 123456 Enter password:******</code></p>
<p>####注：上面的**是自己输入的654321。</p>
<p>###3.2 SET PASSWORD 语句</p>
<p>格式如下：</p>
<p><code>SET PASSWORD FOR username@hostname=PASSWORD(&#39;password&#39;);</code></p>
<p>其中，username为用户名，hostname为指定的主机，password为新密码。</p>
<p>这种方式需要先登入mysql控制台，即通过正确用户名、密码登入。</p>
<p>例如：设置在localhost上的用户user的密码为123456，则</p>
<p><code>SET PASSWORD FOR user@localhost=PASSWORD(&#39;123456&#39;);</code></p>
<p>####注：通过这种方式修改自己的密码，可以只有基本的USAGE权限；如果修改其他人的密码，需要对mysql数据库存在UPDATE权限。</p>
<p>###3.3 UPDATE user 语句</p>
<p>格式如下：</p>
<p><code>UPDATE mysql.user SET password=PASSWORD(&#39;password&#39;) WHERE user=&#39;username&#39; and host=&#39;hostname&#39;; FLUSH PRIVILEGES;</code></p>
<p>其中，mysql.user表示mysql库中的user表，user表示字段为user，username为用户名，password为新密码，hostname为指定的主机。</p>
<p>这种方式需要先登入mysql控制台，即通过正确用户名、密码登入。</p>
<p>例如：设置用户user的密码为123456，则</p>
<p><code>UPDATE mysql.user SET password=PASSWORD(&#39;123456&#39;) WHERE user=&#39;user&#39; and host=&#39;localhost&#39;; FLUSH PRIVILEGES;</code></p>
<p>####注：因为这种方式是手动修改数据库，如果想要这种修改立马生效，还需执行FLUSH PRIVILEGES命令刷新用户权限列表，所以需要登录的用户有SELECT、UPDATE、RELOAD三种权限。</p>
<p>##4 删除用户</p>
<p>在mysql中，可以通过直接删除mysql.user表中的数据删除用户，也可以通过drop命令删除用户，与创建用户的操作类似。</p>
<p>###4.1 DELETE FROM mysql.user</p>
<p>格式如下：</p>
<p><code>DELETE FROM mysql.user WHERE user=&#39;username&#39; and host=&#39;hostname&#39;</code></p>
<p>其中，mysql.user表示mysql库中的user表，user表示字段为user，username为用户名，hostname为指定的主机。</p>
<p>###4.2 DROP USER username</p>
<p>格式如下：</p>
<p><code>DROP USER &#39;username&#39;@&#39;hostname&#39;</code></p>
<p>其中，username为用户名，hostname为指定的主机。<br>————————————</p>
<p>  #mysql  #anthority  #y运维</p>
]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层</title>
    <url>/2021/05/17/%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1>物理层</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>物理层的作用的是接收数据链路层传来的0、1字符串，并把它们转换成电信号（考虑多大电压代表0、1），在传输媒体上传播，并且定义了管理这些媒体的机械，电气，功能，过程的特性。</p>
<a id="more"></a>
<h2 id="二、数据通信的基本概念"><a href="#二、数据通信的基本概念" class="headerlink" title="二、数据通信的基本概念"></a>二、数据通信的基本概念</h2><blockquote>
<p>备注：计算机通信只是数据通信中的一种，还有其他的</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gaf8tmf8l6j31em0p8qam.jpg" alt=""></p>
<h3 id="1、数据通信的模型：源系统-gt-传输系统-gt-目的系统"><a href="#1、数据通信的模型：源系统-gt-传输系统-gt-目的系统" class="headerlink" title="1、数据通信的模型：源系统 ==&gt; 传输系统 ==&gt; 目的系统"></a>1、数据通信的模型：源系统 ==&gt; 传输系统 ==&gt; 目的系统</h3><h3 id="2、相关术语"><a href="#2、相关术语" class="headerlink" title="2、相关术语"></a>2、相关术语</h3><ul>
<li>数据（data）：运送信息的实体（数据是信息的载体，不是信息的本身）。</li>
<li>信号（signal）：数据的电气或电磁的1表现。</li>
<li>码元：不同离散数值的基本波形（二进制编码中只有两种码元，0状态和1状态</li>
<li>模拟的（analogous）：连续变化的</li>
<li>数字的（digital）：取值是离散的</li>
<li>调制：把数字信号转换成模拟信号。</li>
<li>解调：把模拟信号换成数字信号。</li>
</ul>
<h3 id="3、信道"><a href="#3、信道" class="headerlink" title="3、信道"></a>3、信道</h3><p>1）基本概念</p>
<p>表示某一个方向传送信息的媒体</p>
<p>1）通信方式：</p>
<ul>
<li>单工通信</li>
<li>半双工通信</li>
<li>全双工通信</li>
</ul>
<p>2）信道（传输系统）基本概念</p>
<ul>
<li>基带信号：来自信源的信号。  <ul>
<li>编码：对基带信号的波形进行变换，使它能够与信道特信相适应，变换后的信号仍然是基带信号。</li>
<li>编码方式：单极性不归零码，双极性不归零码，单极性归零码，双极性归零码，曼彻斯特编码（能携带时钟信号，可以表示没有数据传输），差分曼彻斯特编码（抗干扰性能强于前者）</li>
</ul>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gflqtbblkfj316m0fq7hy.jpg" alt=""></p>
<ul>
<li><p>带通信号（调制）：经过载波调制后的信号。</p>
<ul>
<li>调制：使用载波进行调制，把基带信号的频率范围搬迁到较高的频段，并转换为模拟信号。</li>
<li>调制方法：调幅（AF），调频（FM），调相（PM）</li>
</ul>
</li>
</ul>
<p>3）信道的极限容量 ==&gt; 奈式准则：没有信号干扰，码元的传输速率有上限</p>
<p>限制码元在信道上传输速率的因素</p>
<ul>
<li><p>信道能够通过的频率范围：在任何信道中，码元传输的速率都有上限，超过这个上限，就会出现严重的码间串扰问题。</p>
</li>
<li><p>信噪比：信号的平均功率 / 噪声的平均功率（S / N）</p>
</li>
</ul>
<p>香农公式（传多远会是真）：有信号干扰，无差错传输速率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">信道的极限信息传输速率：C = Wlog2(1 + S / N) b/s</span><br><span class="line">W // 带宽</span><br><span class="line">S // 信道内所传信号的平均功率</span><br><span class="line">N // 信道内的高斯噪声功率</span><br></pre></td></tr></table></figure>
<h2 id="三、传输媒体"><a href="#三、传输媒体" class="headerlink" title="三、传输媒体"></a>三、传输媒体</h2><p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gafb9kcavqj31dm0s6gqp.jpg" alt=""></p>
<h3 id="1、导向传输媒体（电磁波沿着固体媒体传播）"><a href="#1、导向传输媒体（电磁波沿着固体媒体传播）" class="headerlink" title="1、导向传输媒体（电磁波沿着固体媒体传播）"></a>1、导向传输媒体（电磁波沿着固体媒体传播）</h3><p>1）金属介质（传电信号实现数据通信）：双绞线（屏蔽双绞线STP，无屏蔽双绞线UTP），同轴电缆（50欧用于数字传输，75欧用于模拟传输）</p>
<ul>
<li><p>直通线：比如计算机和交换机连</p>
</li>
<li><p>交叉线：（以前有线序，现在网卡进步后，不需要了）</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">同类设备交叉线，不同类直通线。</span><br></pre></td></tr></table></figure>
<p>2）光缆（光信号实现数据通信）：光纤（多模，单模）</p>
<h3 id="2、非导向传输媒体（电磁波传输称为无线通信）"><a href="#2、非导向传输媒体（电磁波传输称为无线通信）" class="headerlink" title="2、非导向传输媒体（电磁波传输称为无线通信）"></a>2、非导向传输媒体（电磁波传输称为无线通信）</h3><p>短波通信质量差，微波直线传播：地面微波接力通信，卫星通信 ）</p>
<h3 id="3、物理层设备"><a href="#3、物理层设备" class="headerlink" title="3、物理层设备"></a>3、物理层设备</h3><ul>
<li>中继器：负责在两个节点的物理层上按位传递信息，完成信号的复制、调整和放大功能，以此来延长网络的长度，无路径检测和交换功能</li>
<li>集线器：用于加强信号（只把比特流传过去，不作任何判断，也看不懂数据链路层的东西，可以看成线）</li>
<li>交换机：交换机是根据Mac地址来转发数据的，它接收数据帧，然后存储看他的Mac地址，选择出口，决定往哪里转发</li>
</ul>
<h2 id="四、信道复用技术"><a href="#四、信道复用技术" class="headerlink" title="四、信道复用技术"></a>四、信道复用技术</h2><p>1、频分复用</p>
<p>2、时分复用（可能使线路资源浪费）</p>
<p>3、统计时分复用（放的时候无规律，分的时候用标记来分）</p>
<p>4、波分复用（光的频分复用）</p>
<h2 id="五、宽度接入技术"><a href="#五、宽度接入技术" class="headerlink" title="五、宽度接入技术"></a>五、宽度接入技术</h2><p>1、ADSL（用电话线接入</p>
<p>2、HFC：（用有线电视的铜线接入</p>
<p>3、FTTx：（光纤到户</p>
</div><div class="post-tag-list">标签: <a class="post-tags" href="/tags/网络安全/">网络安全]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层</title>
    <url>/2021/05/16/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<p>数据链路：除了物理线路外，还必须有通信协议来控制这些数据的传输。</p>
<p>数据链路层的作用：把从网络层接收到的数据分割成可以被物理层传输的帧。（向网络层提供一个定义良好的服务接口；处理传输错误；调节数据流，确保慢速的接收方不会被快速的发送方淹没）</p>
<a id="more"></a>
<p>帧：数据链路层按照具体协议要求由比特流装配而成。（数据链路层传输的协议数据单元）</p>
<p>帧的结构：帧的结构设计必须要有帧首和帧尾的标识方法（首部和尾部的一个重要作用就是进行帧定界），以标识帧的开始和结束，还要包括校验信息和帧序号，以便检测出传输中出现的差错和保持帧传输的有序性。</p>
<p>信道类型：点对点信道、广播信道。</p>
<p>数据链路层协议：点对点协议 ppp、</p>
<p>三个基本问题：</p>
<ul>
<li><p>封装成帧：在一段数据的前后分别添加首部 SOH 和尾部 EOT，然后就构成了一个帧。首部和尾部确定了帧的界限。</p>
</li>
<li><p>透明传输：传输的数据中没有首部和尾部的帧定界符。</p>
</li>
<li><p>差错检测：比特差错、帧丢失、重复、失序。（循环冗余检验CRC）</p>
</li>
</ul>
<h2 id="二、点对点信道"><a href="#二、点对点信道" class="headerlink" title="二、点对点信道"></a>二、点对点信道</h2><blockquote>
<p> 点对点协议 ppp（世界上使用最多的数据链路层协议）==&gt; 广域网</p>
</blockquote>
<h3 id="1、特点"><a href="#1、特点" class="headerlink" title="1、特点"></a>1、特点</h3><p>1）应满足的功能：</p>
<ul>
<li>简单 —— 这是首要的要求。</li>
<li>封装成帧 —— 必须规定特殊的字符作为帧定界符。</li>
<li>透明性 —— 必须保证数据传输的透明性。</li>
<li>多种网络层协议 —— 能够在同一条物理链路上同时支持多种网络层协议。</li>
<li>多种类型链路 —— 能够在多种类型的链路上运行。</li>
<li>差错检测 —— 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</li>
<li>检测连接状态 —— 能够及时自动检测出链路是否处于正常工作状态。</li>
<li>最大传送单元 —— 必须对每一种类型的点对点链路设置最大传送单元  MTU 的标准默认值，促进各种实现之间的互操作性。</li>
<li>网络层地址协商 —— 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址。</li>
<li>数据压缩协商 —— 必须提供一种方法来协商使用数据压缩算法</li>
</ul>
<p>2）组成： </p>
<ul>
<li>将 IP 数据报封装到串行链路。</li>
<li>链路控制协议 LCP (Link Control Protocol)：建立并维护数据链路连接</li>
<li>网络控制协议 NCP (Network Control Protocol)：允许在点到点连接上使用多种网络层协议</li>
</ul>
<h3 id="2、帧格式"><a href="#2、帧格式" class="headerlink" title="2、帧格式"></a>2、帧格式</h3><p>PPP 帧的首部和尾部分别为 4 个字段和 2 个字段。</p>
<p>1）标志字段 F 规定为 0x7E，表示一个帧的开始或结束。</p>
<p>2）地址字段 A 只置为 0xFF。地址字段实际上并不起作用。</p>
<p>3）控制字段 C 通常置为 0x03。</p>
<p>4）PPP 是面向字节的，所有的 PPP 帧的长度都是整数字节</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfgptpwh51j30qs07oabn.jpg" alt=""></p>
<p>解决透明传输（当 PPP 用在同步传输链路时，协议规定采用硬件来完成<strong>零比特填充</strong>（和 HDLC 的做法一样）。当 PPP 用在异步传输时，就使用一种特殊的<strong>字符填充法</strong>）</p>
<h3 id="3、工作状态"><a href="#3、工作状态" class="headerlink" title="3、工作状态"></a>3、工作状态</h3><p>1）用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</p>
<p>2）PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</p>
<p>3）这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</p>
<p>4）通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。</p>
<p>5）LCP 释放数据链路层连接。</p>
<p>6）释放物理层的连接。</p>
<blockquote>
<p> PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。     </p>
</blockquote>
<h2 id="三、广播信道"><a href="#三、广播信道" class="headerlink" title="三、广播信道"></a>三、广播信道</h2><blockquote>
<p> CSMA / CD 协议（广播指所有的计算机都能收到信号）==&gt; 局域网</p>
</blockquote>
<h3 id="1、特点-1"><a href="#1、特点-1" class="headerlink" title="1、特点"></a>1、特点</h3><p>可以随意的在网络中添加设备</p>
<h3 id="2、局域网的拓扑"><a href="#2、局域网的拓扑" class="headerlink" title="2、局域网的拓扑"></a>2、局域网的拓扑</h3><p>星形网、环形网、总线网</p>
<h3 id="3、数据链路层的两个子层"><a href="#3、数据链路层的两个子层" class="headerlink" title="3、数据链路层的两个子层"></a>3、数据链路层的两个子层</h3><blockquote>
<p> 为了使数据链路层能更好地适应多种局域网标准</p>
</blockquote>
<p>1）逻辑链路控制 LLC (Logical Link Control)子层（作用已经消失）</p>
<p>2）媒体接入控制 MAC (Medium Access Control)子层：实现一对一通信是通过地址来实现的</p>
<h3 id="4、适配器"><a href="#4、适配器" class="headerlink" title="4、适配器"></a>4、适配器</h3><p>1）概念</p>
<p>适配器是网络接口板又称为通信适配器 (adapter) 或网络接口卡 NIC (Network Interface Card)，或网卡。用于和外界局域网进行连接。</p>
<p>2）功能</p>
<ul>
<li><p>进行数据串行传输（和局域网）和并行传输（和计算机）的转换</p>
</li>
<li><p>对数据进行缓存（因为网络上的数据率和计算机总线上的数据率不同）</p>
</li>
<li><p>在计算机的操作系统安装管理适配器的设备驱动程序（告诉适配器应该从存储的什么位置把多长的数据块发送到局域网；或在存储器的什么位置把局域网传过来的数据块记录下来）</p>
</li>
<li><p>实现以太网协议</p>
</li>
</ul>
<p>3）工作过程</p>
<p>适配器在接收和发送各种帧时，不使用计算机的CPU。这时计算机中的CPU可以处理其他任务。当适配器收到有差错的帧时，就把这个帧直接丢弃而不必通知计算机。当适配器收到正确的帧时，它就使用中断来通知该计算机，并交付协议栈中的网络层。当计算机要发送IP数据报时，就由协议栈把IP数据报向下交给适配器，组装成帧后发送到局域网。</p>
<h3 id="3、CSMA-CD-协议（载波监听多点接入-碰撞检测-）"><a href="#3、CSMA-CD-协议（载波监听多点接入-碰撞检测-）" class="headerlink" title="3、CSMA / CD 协议（载波监听多点接入 / 碰撞检测  ）"></a>3、CSMA / CD 协议（载波监听多点接入 / 碰撞检测  ）</h3><blockquote>
<p>总线上只要有一台计算机在发送数据，总线的传输资源就被占用。所以在同一时间只能允许一台计算机发送数据， 否则各计算机之间就会互相干扰，使得所发送数据被破坏。</p>
</blockquote>
<p>1）特点</p>
<ul>
<li><p>多点接入：说明这是总线型网络，许多计算机以多点接入的方式连接在一根总线上。</p>
</li>
<li><p>载波监听：用电子技术检测总线上有没有计算机也在发送数据。载波监听就是检查信道，不管发送前还是发送中，每个站都必须不停地检查信道。</p>
</li>
<li><p>碰撞检测：边发送边检测。即适配器边发送数据边检测信道上的信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。</p>
<ul>
<li>信号传播时延对载波监听的影响 </li>
<li>使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。</li>
<li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。如果希望在以太网上发生碰撞的机会很小， 必须使整个以太网的平均通信量远小于以太网的最高数据率。 </li>
<li>经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。</li>
<li>以太网使用二进制指数类型退避算法来确定碰撞后重传的时机。</li>
</ul>
</li>
</ul>
<h2 id="四、以太网"><a href="#四、以太网" class="headerlink" title="四、以太网"></a>四、以太网</h2><h3 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h3><p>1）以太网（Ethernet）是一种星型拓扑结构局域网。而局域网却不一定是以太网。</p>
<p>2）以太网是目前应用最广泛的局域网。</p>
<p>3）以太网使用 CSMA/CD 协议。</p>
<h3 id="2、集线器"><a href="#2、集线器" class="headerlink" title="2、集线器"></a>2、集线器</h3><p>用于加强信号（只把比特流传过去，不作任何判断，也看不懂数据链路层的东西，可以看成线）</p>
<p>同轴电缆 =&gt; 双绞线 =&gt; 集线器　</p>
<h3 id="3、信道利用率"><a href="#3、信道利用率" class="headerlink" title="3、信道利用率"></a>3、信道利用率</h3><p>信道利用率表示发送数据的时间占总时间的比值。要提高以太网的信道利用率，就必须减小 t 与 T0 之比。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a = t / T0 <span class="comment"># 以太网单程端到端时延 t 与帧的发送时间 T0 之比。</span></span><br><span class="line"> </span><br><span class="line">α →0，表示一发生碰撞就立即可以检测出来， 并立即停止发送，因而信道利用率很高。</span><br><span class="line">α 越大，表明争用期所占的比例增大，每发生一次碰撞就浪费许多信道资源，使得信道利用率明显降低。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对以太网参数 α 的要求：</span></span><br><span class="line">当数据率一定时，以太网的连线的长度受到限制，以太网的帧长不能太短，否则 T0 的值会太小，使 α 值太大。</span><br></pre></td></tr></table></figure>
<h3 id="4、MAC-层"><a href="#4、MAC-层" class="headerlink" title="4、MAC 层"></a>4、MAC 层</h3><p>1）概念</p>
<p>MAC 地址又称硬件地址、物理地址、适配器地址或适配器标识符 EUI-48，是一个用来确认网上设备位置的地址。</p>
<p>2）MAC 帧的格式</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfnl57lwzqj30tq0awdj8.jpg" alt=""></p>
<p>3）区别</p>
<ul>
<li><p>以太网和数据链路层和物理层有关，以太网使用同轴电缆或双绞线电缆，可以解释其中的0、1以何种电子信号。</p>
</li>
<li><p>ppp 只与数据链路层有关，要实现通信还需要物理层的支持。</p>
</li>
</ul>
<h3 id="5、扩展的以太网"><a href="#5、扩展的以太网" class="headerlink" title="5、扩展的以太网"></a>5、扩展的以太网</h3><p>网桥 =&gt; 接口多了慢慢发展为交换机（存储转发），替代了集线器</p>
<p>带宽独享，全双工，安全，基于Mac地址转发数据</p>
<h3 id="6、高速以太网"><a href="#6、高速以太网" class="headerlink" title="6、高速以太网"></a>6、高速以太网</h3><p>1）100BASE-T 以太网 </p>
<p>2）吉比特以太网</p>
<p>3）10吉比特以太网 (10GE) 和更快的以太网</p>
<p>4）使用以太网进行宽带接入</p>

</div><div class="post-tag-list">标签: <a class="post-tags" href="/tags/网络安全/">网络安全]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>life only such as first</title>
    <url>/2021/05/15/life-only-such-as-first/</url>
    <content><![CDATA[<p>···If life is only as first, how good it should be, we still had the appearance of happiness, but unfortunately, time let us walk away from the original direction.</p>
<pre><code>Looking out of the window, the sky elongated face   obviously make some unhappy little mood, listen to &quot;because of love&quot; together a Fu of the tune and then think of the past past, really not a taste. &quot;
</code></pre>
<p>···Because of love, not easily sad, so everything is the appearance of happiness; Because of love, simple growth, still can be crazy for you at any time. “How difficult beautiful lyrics, how beautiful melody, but it is a pity that we did not smooth the original heartbeat.</p>
<p>···If everything is the original shape, everything is not easily sad, like nalanxingde “magnolia” in “if life only such as first” that it would be good, so can we see in the world will be more to a happy ending. “if life only such    as first, what the autumn wind sad picture fan, afford to change, so the heart, but way so the heart variable.” Nalanxingde’s poetry is dreamlike and beautiful, in which the woman’s tone complains the man’s thoughtlessness. We cannot easily describe the elegance of the language in the poem with words, nor can we easily capture the intangible beauty in the poem with inspiration.</p>
<pre><code>Life if only such as first, then the world how perfect!
</code></pre>
<p>Everything is the original happiness of the appearance, everything will not easily sad, everything can be crazy for you at any time!<br><img src="https://blog.zhangruipeng.me/hexo-theme-minos/gallery/compass.jpg" alt="https://blog.zhangruipeng.me/hexo-theme-minos/gallery/compass.jpg"><br>#假设人生</p>
<p>##和你  和家人</p>
]]></content>
      <tags>
        <tag>爱情记录</tag>
      </tags>
  </entry>
  <entry>
    <title>五一</title>
    <url>/2021/05/11/%E4%BA%94%E4%B8%80/</url>
    <content><![CDATA[<p>#成都的魅力<br>————————————————————————————————</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这是我们第一次在相隔遥远的地方一起奔赴同一个地方见面</span><br><span class="line"></span><br><span class="line">![IMG_20210503_215914.jpg](https:&#x2F;&#x2F;i.loli.net&#x2F;2021&#x2F;05&#x2F;09&#x2F;aIhqTkXDLdAR3r4.jpg)</span><br></pre></td></tr></table></figure>
<p>###我的拍照技术挺好的<br><img src="https://i.loli.net/2021/05/09/si79qSxp2kXDMU1.jpg" alt="IMG_20210503_220441.jpg"><br>###把本来就很漂亮的你拍的如此美丽哈哈！</p>
<p><img src="https://i.loli.net/2021/05/09/RBiYNLkmsQGFSgW.jpg" alt="IMG_20210503_220056.jpg"><br>###冰淇淋要滴到衣服上面啦<br><img src="https://i.loli.net/2021/05/09/Dv9bBdO8PXNhenT.jpg" alt="IMG_20210503_220543.jpg"><br>###随便一个抓拍就能留下我们共同走过的地方</p>
<p><img src="https://i.loli.net/2021/05/09/qbdBs3LVfzThDF4.jpg" alt="IMG_20210504_174439.jpg"><br>###鳌山真的很不错呢<br>————————————————————————————————————</p>
]]></content>
      <tags>
        <tag>爱情记录</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层</title>
    <url>/2021/05/10/%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h1>网络层</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>负责在不同网络之间转发数据报（实现这个功能的设备是路由器，即实现跨网段的数据通信），基于数据报的IP地址转发（即选择出口，路由器对出口的判断是根据路由表），不负责丢失重传，不负责排序。</p>
<a id="more"></a>
<h2 id="二、网际协议-IP"><a href="#二、网际协议-IP" class="headerlink" title="二、网际协议 IP"></a>二、网际协议 IP</h2><blockquote>
<p>IP协议：所有选路的协议都是 IP 协议</p>
</blockquote>
<h3 id="1、计算机通信的过程"><a href="#1、计算机通信的过程" class="headerlink" title="1、计算机通信的过程"></a>1、计算机通信的过程</h3><p>1）计算机通信的过程（本网段通信和跨网段通信的过程）</p>
<ul>
<li>应用层：应用程序准备要传输的文件</li>
<li>传输层：将文件分段，并编号</li>
<li>网络层：添加目标IP地址，源IP地址</li>
<li>数据链路层：使用自己的子网掩码，判断自己在哪个网段。使用自己的子网掩码，判断目标地址在哪个网段<ul>
<li>同一网段：用ARP协议广播解析目标地址的Mac地址，得到对方的Mac地址后，用对方的Mac地址直接封装。</li>
<li>不是同一网段：把数据发给路由器，让他来转发数据（此时的目标地址是网关的Mac地址）</li>
</ul>
</li>
</ul>
<p>2）网络设备</p>
<ul>
<li><p>网关：网关是一个 IP 地址。是一个网络连接到另一个网络的“关口”。</p>
</li>
<li><p>路由器：路由器是一个物理设备。一般局域网的网关就是路由器的IP地址。路由器仅根据目的主机所连接的网络号来转发数据报。路由器总是具有两个或两个以上的 IP 地址。路由器的每一个接口都有一个不同网络号的 IP 地址。</p>
</li>
</ul>
<h3 id="2、IP-地址"><a href="#2、IP-地址" class="headerlink" title="2、IP 地址"></a>2、IP 地址</h3><p>1）IP 地址的定义</p>
<p>要使 Internet 上的主机间能正常通信，必须给每个计算机一个全球都能接收和识别的唯一标识，即IP地址。IP 地址就是给每个连接在互联网上的主机或路由器分配一个在全世界范围是唯一的 32 位的标识符。</p>
<p>IP 地址现在由互联网名字和数字分配机构 ICANN 进行分配。</p>
<p>2）IP 地址和 MAC 地址的区别</p>
<ul>
<li>IP 地址决定数据报的起点和终点，是一种逻辑地址，是网络层和以上各层使用的地址。</li>
<li>MAC 地址决定了下一跳的路径，是一种物理地址，是数据链路层和物理层使用的地址。【数据要在数据链路层上传，就要写上数据链路层的地址，即物理访问地址 Mac 地址】</li>
</ul>
<p>3）IP 地址编址方法经历的历史阶段</p>
<blockquote>
<h4 id="第一阶段：分类的-IP-地址"><a href="#第一阶段：分类的-IP-地址" class="headerlink" title="第一阶段：分类的 IP 地址"></a>第一阶段：分类的 IP 地址</h4></blockquote>
<p>将 IP 地址划分为 A 类（网络号1位，主机号3位），B 类（网络号2位，主机号2位），C 类（网络号3位，主机号1位），D 类（多播地址），E 类（保留为今后使用）5 个类别。每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号 host-id，它标志该主机（或路由器）。主机号在它前面的网络号所指明的网络范围内必须是唯一的。所以一个 IP 地址在整个互联网范围内是唯一的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfqqqoqrxnj30ry0a6416.jpg" alt=""></p>
<blockquote>
<h4 id="第二阶段：子网的划分"><a href="#第二阶段：子网的划分" class="headerlink" title="第二阶段：子网的划分"></a>第二阶段：子网的划分</h4></blockquote>
<p>（1）划分原因</p>
<p>IP 地址空间的利用率有时很低。 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。两级的 IP 地址不够灵活。</p>
<p>（2）划分子网的思路</p>
<p>从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。</p>
<p>从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号subnet-id 找到目的子网。最后就将 IP 数据报直接交付目的主机。 </p>
<p>划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。从两级 IP 地址到三级 IP 地址。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure>
<p>（3）子网掩码</p>
<p>从一个 IP 数据报的首部无法判断源主机或目的主机所连接的网络是否进行了子网划分。所以就出现了子网掩码(subnet mask)，它可以找出 IP 地址中的子网部分。</p>
<p>子网掩码长度＝32位。某位＝1表示IP地址中的对应位为网络号和子网号，某位＝0表示IP地址中的对应位为主机号。使用子网掩码的好处是不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位相“与”（AND）就能立即得出网络地址。</p>
<blockquote>
<h4 id="第三阶段：无分类编址-CIDR（构成超网）"><a href="#第三阶段：无分类编址-CIDR（构成超网）" class="headerlink" title="第三阶段：无分类编址 CIDR（构成超网）"></a>第三阶段：无分类编址 CIDR（构成超网）</h4></blockquote>
<p>（1）网络前缀</p>
<p>划分子网在一定程度上缓解了因特网发展中遇到的困难。但是 IP 地址面临不够用的问题。</p>
<p>CIDR 的特点</p>
<ul>
<li>CIDR 消除了传统的 A 类、B 类和 C 类地址及划分子网的概念，把32位的 IP 地址划分为两个部分，前面的部分是<strong>网络前缀</strong>，用来指明网络，后面的部分用来指明主机，因此 CIDR 使 IP 地址从三级编址（使用子网掩码）又回到两级编址。CIDR 在 IP 地址后面加上斜线“/”，然后写上网络前缀所占的位数。128.14.35.7/20</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IP 地址 ::= &#123;&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>CIDR把网络前缀都相同的连续IP地址组成一个“CIDR地址块。</li>
</ul>
<p>（2）最长前缀匹配</p>
<p>在使用 CIDR 时，由于采用了网络前缀这种记法，IP地址由网络前缀和主机号两部分组成，因此在路由表中的项目也要做相应的改变。每个项目由“网络前缀”和”下一跳地址“组成。但在查找路由表时可能得到不止一个匹配结果，此时从匹配结果中选择具有最长网络前缀的路由。这时因为网络前缀越长，其地址块就越小，因而路由就越具体。即选择匹配的地址更具体的一个。</p>
<h3 id="3、IP数据报的格式（IPv4）"><a href="#3、IP数据报的格式（IPv4）" class="headerlink" title="3、IP数据报的格式（IPv4）"></a>3、IP数据报的格式（IPv4）</h3><p><img src="https://img-blog.csdn.net/20180624172532216?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1lpbl9Ib25nd2Vp/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>IP 数据报由首部和数据两部分组成。IP 数据报首部的固定部分中的各字段为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、版本：4位，用来表示表示 IP 协议的版本。IPv4，IPv6。</span><br><span class="line">2、首部长度：4位，首部是20个字节固定长度。</span><br><span class="line">3、区分服务：8位，用来获得更好地服务（只有使用时，该字段才起作用，一般也不用）。</span><br><span class="line">网络层-数据报 65535 字节</span><br><span class="line">数据链路层-数据 1500 字节（最大传输单元MTU）</span><br><span class="line">当数据包比数据链路层所支持的帧大的时候，数据报要进行分片。数据报如果不分片，数据报数据最大不超过1480字节</span><br><span class="line">4、总长度：16位，首部和数据之和的长度。</span><br><span class="line">5、标识：16位，不一定连续。</span><br><span class="line">6、标志：3位，目前只有两位有意义。</span><br><span class="line">标志字段的最低位记为MF，MF=1表示后面还有分片的数据报，MF=0表示这已是若干数据报片中的最后一个。</span><br><span class="line">标志字段中间的一位记为DF，意思是不能分片，当DF=0时才允许分片。</span><br><span class="line">7、片偏移：13位，较长的分组在分片后，某片在原分组中的相对位置。</span><br><span class="line">8、生存时间：8位，每过一个路由器，生存时间都要修改，物理层地址也要修改</span><br><span class="line">9、协议：8位，协议号就规定了里面的数据应该由哪个协议进行处理。（不同的协议在网络层用协议号来进行1区分）</span><br><span class="line">协议号：ICMP 1 ，IGMP 2 ，TCP 6， UDP 17 ，IPv6 41，OSPF 89，</span><br><span class="line">10、首部检验和：16位，用于检验数据包在传的过程中是否被修改或者出现了错误。接收端发现检验正确，接收数据，发现检验错误，丢弃数据报。</span><br><span class="line">11、原地址：32位，源IP地址。</span><br><span class="line">12、目的地址：32位，目标IP地址。</span><br><span class="line">13、可选字段（长度可变）：用于支持排错，测量以及安全等措施。它增加了IP数据报的功能，IPv6没有这个可变部分了。</span><br><span class="line">14、填充：当IP分组的首部长度不是4字节的整数倍，填充0，使其是4字节的整数倍。</span><br></pre></td></tr></table></figure>
<h3 id="4、IPv6"><a href="#4、IPv6" class="headerlink" title="4、IPv6"></a>4、IPv6</h3><p>解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的 IP</p>
<p>1）IPv6 引进的主要变化</p>
<ul>
<li>更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。 </li>
<li>扩展的地址层次结构。 </li>
<li>灵活的首部格式。 IPv6 定义了许多可选的扩展首部。</li>
<li>改进的选项。 </li>
<li>允许协议继续扩充。 </li>
<li>支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。</li>
<li>支持资源的预分配。  IPv6 支持实时视像等要求，保证一定的带宽和时延的应用。</li>
<li>IPv6 首部改为 8 字节对齐。首部长度必须是 8 字节的整数倍。原来的 IPv4 首部是 4 字节对齐。</li>
</ul>
<p>2）IPv6 数据报的结构</p>
<ul>
<li><p>基本首部 ：首部长度变为固定的 40 字节。把首部中不必要的功能取消了，使得 IPv6 首部的字段数减少到只有 8 个。</p>
</li>
<li><p>有效载荷 ：有效载荷也称为净负荷。有效载荷允许有零个或多个扩展首部(extension header)，再后面是数据部分。</p>
</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfqu3nlvbfj30tm0ds42k.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、版本：4 位。它指明了协议的版本，对 IPv6 该字段总是 6。 </span><br><span class="line">2、通信量类：8 位。这是为了区分不同的 IPv6 数据报的类别或优先级。目前正在进行不同的通信量类性能的实验。 </span><br><span class="line">3、流标号：20 位。 “流”是互联网络上从特定源点到特定终点的一系列数据报， “流”所经过的路径上的路由器都保证指明的服务质量。所有属于同一个流的数据报都具有同样的流标号。 </span><br><span class="line">4、有效载荷长度：16 位。它指明 IPv6 数据报除基本首部以外的字节数（所有扩展首部都算在有效载荷之内），其最大值是 64 KB。 </span><br><span class="line">5、下一个首部：8 位。它相当于 IPv4 的协议字段或可选字段。 </span><br><span class="line">6、跳数限制：8 位。源站在数据报发出时即设定跳数限制。路由器在转发数据报时将跳数限制字段中的值减 1。当跳数限制的值为零时，就要将此数据报丢弃。 </span><br><span class="line">7、源地址：128 位。是数据报的发送站的 IP 地址。 </span><br><span class="line">8、目的地址：128 位。是数据报的接收站的 IP 地址。</span><br></pre></td></tr></table></figure>
<p>4）地址分类</p>
<ul>
<li><p>单播：每个以太网帧包含源主机和目的主机的以太网地址。通常每个以太网帧发往单个目的主机，目的地址指明单个接收接口</p>
</li>
<li><p>多播：一个主机要向网上的多个主机发送帧</p>
</li>
<li><p>广播：一个主机要向网上的所有其他主机发送帧</p>
</li>
</ul>
<blockquote>
<p> 广播和多播仅应用于 UDP</p>
</blockquote>
<p>5）IPv4 向 IPv6 过渡的策略</p>
<ul>
<li>双协议栈</li>
<li>隧道技术</li>
</ul>
<h2 id="三、地址解析协议-ARP"><a href="#三、地址解析协议-ARP" class="headerlink" title="三、地址解析协议 ARP"></a>三、地址解析协议 ARP</h2><h3 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h3><p>ARP 协议是解决同一个局域网上主机（或路由器）的 IP 地址和硬件地址的映射关系</p>
<h3 id="2、解析-MAC-地址的过程"><a href="#2、解析-MAC-地址的过程" class="headerlink" title="2、解析 MAC 地址的过程"></a>2、解析 MAC 地址的过程</h3><p>1）主机A向本局域网上的主机B发送IP数据报时，在其ARP高速缓存中查看有无主机B的IP地址，如果有，就在其ARP高速缓存中查出其对应的MAC地址，再把这个MAC地址写入MAC帧，然后通过局域网把该MAC帧发往这个MAC地址。</p>
<p>2）如果查不到主机B的IP地址，主机A自动运行ARP，ARP进程在本局域网上广播发送一个ARP请求分组</p>
<p>==&gt; 在本局域网上的所有主机上运行的ARP进程都收到此ARP请求分组</p>
<p>==&gt; 主机B的IP地址和ARP请求分组中要查询的IP地址一样，就收下这个ARP请求分组，并向主机A发送ARP相应分组（普通的单播），同时在这个ARP相应分组中写入自己的Mac地址。</p>
<p>==&gt; 主机A收到主机B的ARP相应分组后，在其ARP高速缓存中写入主机B的IP地址到MAC地址的映射</p>
<p>==&gt; 如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p>
<h3 id="3、ARP攻击"><a href="#3、ARP攻击" class="headerlink" title="3、ARP攻击"></a>3、ARP攻击</h3><p>按照 IETF 的规定，PC机在发出ARP响应时，不需要一定要先收到ARP请求报文；局域网任何一台计算机都可以向网上发出自己就是IP_A和MAC_A的对应者，这就为攻击者带来了漏洞。</p>
<p>1）ARP欺骗：网络执法官，p2p终结者</p>
<p>2）ARP流量攻击</p>
<h2 id="四、网际控制报文协议-ICMP"><a href="#四、网际控制报文协议-ICMP" class="headerlink" title="四、网际控制报文协议 ICMP"></a>四、网际控制报文协议 ICMP</h2><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。</p>
<h3 id="1、ICMP报文的种类"><a href="#1、ICMP报文的种类" class="headerlink" title="1、ICMP报文的种类"></a>1、ICMP报文的种类</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfqvatxqo9j30po06q0ug.jpg" alt=""></p>
<h3 id="2、应用举例"><a href="#2、应用举例" class="headerlink" title="2、应用举例"></a>2、应用举例</h3><p>1）ping</p>
<p>用来测试两个主机之间的连通性，ping发送一个ICMP回声请求消息给目的地，并报告是否收到所希望的ICMP回声应答。</p>
<p>排除网络故障， 估算带宽。</p>
<ul>
<li>time：查看延迟</li>
</ul>
<p>2）Traceroute</p>
<p>用来跟踪一个分组从源点到终点的路径。</p>
<ul>
<li><p>TTL：是那个数据包的生存时间，等到TTL变成 0 的时候，那个数据包就在网上自动消失了，可以防止数据包在网上做循环。同时还可以大概的判断对方是什么系统（ Linux：64、Window：128、Unix：255   ）</p>
</li>
<li><p>pathping：跟踪数据包的路径，还能计算丢包率</p>
</li>
<li>tracert：跟踪数据包的路径</li>
</ul>
<h3 id="3、ICMPv6"><a href="#3、ICMPv6" class="headerlink" title="3、ICMPv6"></a>3、ICMPv6</h3><p>因为互联网中的路由器可能会丢弃数据报，IPv6 也不保证数据报的可靠交付。因此 IPv6 也需要使用 ICMP 来反馈一些差错信息。新的版本称为 ICMPv6。</p>
<p>地址解析协议 ARP 和网际组管理协议 IGMP 协议的功能都已被合并到 ICMPv6 中。</p>
<h2 id="五、网际组管理协议-IGMP"><a href="#五、网际组管理协议-IGMP" class="headerlink" title="五、网际组管理协议 IGMP"></a>五、网际组管理协议 IGMP</h2><h3 id="1、IP多播"><a href="#1、IP多播" class="headerlink" title="1、IP多播"></a>1、IP多播</h3><p>目的：更好的支持一对多通信（一个源点发送到许多个终点）</p>
<h3 id="2、IGMP-协议"><a href="#2、IGMP-协议" class="headerlink" title="2、IGMP 协议"></a>2、IGMP 协议</h3><p>IGMP 协议是让连接在本地局域网上的多播路由器知道本局域网上是否有主机参与或退出了某个多播组。</p>
<h3 id="3、多播路由选择协议"><a href="#3、多播路由选择协议" class="headerlink" title="3、多播路由选择协议"></a>3、多播路由选择协议</h3><p>能够运行多播协议的路由器称为多播路由器(multicast router)。 </p>
<h2 id="六、互联网的路由选择协议"><a href="#六、互联网的路由选择协议" class="headerlink" title="六、互联网的路由选择协议"></a>六、互联网的路由选择协议</h2><h3 id="1、内部网关协议-IGP-（路由选择协议）"><a href="#1、内部网关协议-IGP-（路由选择协议）" class="headerlink" title="1、内部网关协议 IGP （路由选择协议）"></a>1、内部网关协议 IGP （路由选择协议）</h3><p>在一个自治系统中使用的内部网关协议。</p>
<p>1）静态路由</p>
<p>需要管理员告诉路由器所有没有直连的网络下一跳给谁。（目的网络地址，下一跳地址）其特点是简单和开销较小，但不能及时适应网络状态的变化 。</p>
<p>2）动态路由</p>
<ul>
<li><p>内部网关协议 RIP：选择的标准是路径。周期性的广播路由表给其他路由器，选择最佳路径，30s更新一次。最大跳数是15。</p>
</li>
<li><p>内部网关协议 OSPF：选择的标准是带宽。</p>
</li>
</ul>
<p>其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。</p>
<h3 id="2、外部网关协议-EGP-（路由选择协议）"><a href="#2、外部网关协议-EGP-（路由选择协议）" class="headerlink" title="2、外部网关协议 EGP （路由选择协议）"></a>2、外部网关协议 EGP （路由选择协议）</h3><p>若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议），当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。 </p>
<h3 id="3、路由器的构成"><a href="#3、路由器的构成" class="headerlink" title="3、路由器的构成"></a>3、路由器的构成</h3><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是路由选择和转发分组。</p>
<p>1）路由选择部分</p>
<p>路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息，不断地更新和维护路由表。</p>
<p>2）分组转发部分</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfrwumadgaj30qs0aetc8.jpg" alt=""></p>
<ul>
<li><p>交换结构：又称为交换组织，其作用是根据转发表对分组进行处理。</p>
<ul>
<li>通过存储器</li>
<li>通过总线</li>
<li>通过纵横交换结构</li>
</ul>
</li>
<li><p>一组输入端口</p>
<ul>
<li>路由器的输入端口里面装有物理层、数据链路层和网络层的处理模块。</li>
<li>数据链路层剥去帧首部和尾部后，将分组送到网络层的队列中排队等待处理。这会产生一定的时延。 </li>
<li>输入端口中的查找和转发功能在路由器的交换功能中是最重要的。</li>
</ul>
</li>
<li><p>一组输出端口</p>
<ul>
<li>输出端口里面装有物理层、数据链路层和网络层的处理模块。</li>
<li>输出端口从交换结构接收分组，然后把它们发送到路由器外面的线路上。</li>
<li>在网络层的处理模块中设有一个缓冲区（队列）。当交换结构传送过来的分组的速率超过输出链路的发送速率时，来不及发送的分组就必须暂时存放在这个队列中。</li>
<li>数据链路层处理模块将分组加上链路层的首部和尾部，交给物理层后发送到外部线路。</li>
</ul>
</li>
</ul>
<blockquote>
<p>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因</p>
</blockquote>
<h3 id="4、路由器转发分组流程"><a href="#4、路由器转发分组流程" class="headerlink" title="4、路由器转发分组流程"></a>4、路由器转发分组流程</h3><p>1）从数据报的首部提取目的主机的IP地址 <strong>D</strong>，得出目的网络地址为 <strong>N</strong>。</p>
<p>2）若 <strong>N</strong> 就是与此路由器直接相连的某个网络地址，则进行直接交付，否则就要执行(3)进行间接交付。</p>
<p>直接把数据报交付给目的主机（这里包括把目的主机地址D转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧）；</p>
<p>3）若路由表中有目的地址为 <strong>D</strong> 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(4)。</p>
<p>4）若路由表中有到达网络 <strong>N</strong> 的路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(5)。</p>
<p>5）若路由表中有一个默认路由，则把数据报传送给路由表中所指明的下一跳路由器，否则执行(6)。</p>
<p>6）报告转发分组出错。</p>
<h2 id="七、VPN"><a href="#七、VPN" class="headerlink" title="七、VPN"></a>七、VPN</h2><div class="qr-code">
</div><div class="post-tag-list">标签: <a class="post-tags" href="/tags/网络安全/">网络安全]]></content>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
</search>
